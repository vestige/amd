<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Amida (Ruby.wasm)</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #out { white-space: pre; border: 1px solid #ccc; padding: 12px; border-radius: 8px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    input { width: 120px; padding: 6px; }
    button { padding: 6px 10px; }
  </style>
</head>
<body>
  <h2>AMD (Ruby.wasm)</h2>

  <div class="row">
    <label>COLS (3..10):</label>
    <input id="cols" type="number" min="3" max="10" value="5" />
    <button id="btnNew">R (Rebuild)</button>
  </div>

  <div class="row">
    <label>Input:</label>
    <input id="inp" placeholder="ex: 3" />
    <button id="btnGo">GO</button>
    <button id="btnEnd">END</button>
  </div>

  <pre id="out"></pre>

  <!-- Ruby.wasm (IIFE) -->
  <script src="https://cdn.jsdelivr.net/npm/@ruby/3.4-wasm-wasi@2.7.2/dist/browser.script.iife.js"></script> <!--  [oai_citation:1‡GitHub](https://github.com/ruby/ruby.wasm?utm_source=chatgpt.com) -->

  <script type="text/ruby">
    require "js"

    DEFAULT_COLS = 5
    ROWS = 12
    H_CHARS = 3
    DENSITY = 0.35
    MIN_BARS_BETWEEN = 2

    def count_bars_between(con, cols)
      counts = Array.new(cols - 1, 0)
      con.each do |row|
        row.each_with_index { |has_bar, i| counts[i] += 1 if has_bar }
      end
      counts
    end

    def count_total_bars(con)
      con.sum { |row| row.count(true) }
    end

    def column_has_any_connection?(con, col, cols)
      con.any? do |row|
        left  = (col > 0) && row[col - 1]
        right = (col < cols - 1) && row[col]
        left || right
      end
    end

    def all_columns_connected_at_least_once?(con, cols)
      cols.times.all? { |c| column_has_any_connection?(con, c, cols) }
    end

    def generate_connections(rows, cols, density: 0.35)
      con = Array.new(rows) { Array.new(cols - 1, false) }

      rows.times do |r|
        (cols - 1).times do |i|
          next if i > 0 && con[r][i - 1]
          next if i < cols - 2 && con[r][i + 1]

          con[r][i] = (rand < density)
        end
      end
      con
    end

    def generate_connections_with_constraints(rows, cols, density:, min_bars_between:)
      loop do
        con = generate_connections(rows, cols, density: density)

        gap_counts = count_bars_between(con, cols)
        next unless gap_counts.all? { |n| n >= min_bars_between } 
        next unless all_columns_connected_at_least_once?(con, cols)

        return con
      end
    end

    def compute_path(connections, start_col, cols)
      col = start_col
      v_marks = {}
      h_marks = {}

      connections.length.times do |r|
        v_marks[[r, col]] = true

        if col > 0 && connections[r][col - 1]
          h_marks[[r, col - 1]] = true
          col -= 1
          v_marks[[r, col]] = true
        elsif col < cols - 1 && connections[r][col]
          h_marks[[r, col]] = true
          col += 1
          v_marks[[r, col]] = true
        end
      end

      v_marks[[connections.length, col]] = true
      [col, v_marks, h_marks]
    end

    def render_str(connections, cols, h_chars, v_marks: nil, h_marks: nil, goals: nil)
      buf = +""
      start_line = (1..cols).map { |n| n.to_s.center(1 + h_chars) }.join
      buf << "START\n"
      buf << " " + start_line + "\n"

      connections.each_with_index do |row_con, r|
        line = +" "
        cols.times do |c|
          on_path = v_marks && v_marks[[r, c]]
          line << (on_path ? "*" : "|")

          if c < cols - 1
            if row_con[c]
              h_on_path = h_marks && h_marks[[r, c]]
              line << (h_on_path ? "*" * h_chars : "-" * h_chars)
            else
              line << " " * h_chars
            end
          end
        end
        buf << line + "\n"
      end

      last = +" "
      cols.times do |c|
        on_path = v_marks && v_marks[[connections.length, c]]
        last << (on_path ? "*" : "|")
        last << " " * h_chars if c < cols - 1
      end
      buf << last + "\n"

      buf << "GOAL\n"
      goal_line =
        if goals
          goals.map { |g| g.center(1 + h_chars) }.join
        else
          (1..cols).map { |n| n.to_s.center(1 + h_chars) }.join
        end
      buf << " " + goal_line + "\n"
      buf
    end

    document = JS.global[:document]
    out  = document.getElementById("out")
    inp  = document.getElementById("inp")
    cols_input = document.getElementById("cols")

    $cols = DEFAULT_COLS
    $connections = nil
    $atari_index = nil
    $goals = nil
    $ended = false

    def new_amida!
      $connections = generate_connections_with_constraints(
        ROWS, $cols, density: DENSITY, min_bars_between: MIN_BARS_BETWEEN
      )
      $atari_index = rand($cols)
      $goals = Array.new($cols) { " " }
      $goals[$atari_index] = "O"
    end

    def redraw(out, v_marks: nil, h_marks: nil)
      out[:textContent] = render_str($connections, $cols, H_CHARS, v_marks: v_marks, h_marks: h_marks, goals: $goals)
    end

    def parse_cols!(cols_input)
      n = cols_input[:value].to_i
      n = DEFAULT_COLS if n == 0
      n = [[n, 3].max, 10].min
      cols_input[:value] = n
      $cols = n
    end

    parse_cols!(cols_input)
    srand
    new_amida!
    redraw(out)

    document.getElementById("btnNew").addEventListener("click") do
      next if $ended
      parse_cols!(cols_input)
      new_amida!
      redraw(out)
    end

    document.getElementById("btnGo").addEventListener("click") do
      next if $ended
      n = inp[:value].to_i
      if n < 1 || n > $cols
        JS.global[:alert].call("1..#{$cols} を入力してね")
        next
      end

      goal_col, v_marks, h_marks = compute_path($connections, n - 1, $cols)
      redraw(out, v_marks: v_marks, h_marks: h_marks)

      if goal_col == $atari_index
        out[:textContent] << "\nResult: #{n}  ATARI!!\n"
      else
        out[:textContent] << "\nResult: #{n}  #{goal_col + 1}\n"
      end
    end

    document.getElementById("btnEnd").addEventListener("click") do
      $ended = true
      out[:textContent] << "\nEnd\n"
    end
  </script>
</body>
</html>
